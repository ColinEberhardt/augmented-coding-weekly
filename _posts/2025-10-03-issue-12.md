---
layout: post
title: ! 'Issue #12'
author: ceberhardt
published: false
---

## [Introducing Claude Sonnet 4.5](https://www.anthropic.com/news/claude-sonnet-4-5)

<small>ANTHROPIC.COM</small>

 - Anthropic positions Sonnet 4.5 as “the best coding model,” citing strong gains on coding, reasoning, math, finance, and “computer use” (OS interaction).
 - Upgrades to Claude Code: an Agent SDK (tools/permissions/context mgmt), revamped terminal, new VS Code extension, and checkpoints to instantly undo changes.
 - Competitive or leading on coding-centric leaderboards; notable speed and cost efficiency vs peers.
 - Big jump in “computer use” scores, suggesting better tool orchestration and parallel tool calls.
 - Early reactions: Mixed but generally positive: some users see modest improvement over 4.0; others report clear gains in instruction-following, parallel tool use, speed, and value.
 - Several note GPT-5 (Code/“codecs”) still leads in “deep reasoning” on tough, long-context problems; Sonnet praised for fast, “light reasoning” and surgical edits.
 - Agentic coding teams (e.g., Devon/Cognition, Factory) report higher reliability, faster multi-hour sessions, better planning, and context-window awareness (with occasional “context anxiety” trade-offs).
 - Imagine with Claude: “model-as-backend” that generates UI and behavior on the fly—early, imperfect, but hints at personalized, ephemeral apps.
 - Anthropic says Sonnet 4.5 ran ~30 hours autonomously to build a Slack-like app (~11k LOC), far exceeding prior run-length reports—if reproducible, a notable shift in the autonomy frontier.
 - Sonnet 4.5 looks like a fast, cost-effective coding workhorse with stronger tool use and OS control. For hardest reasoning tasks, many still prefer GPT-5; optimal workflows likely involve model-switching by task.

## [How Claude Code is built](https://newsletter.pragmaticengineer.com/p/how-claude-code-is-built)

<small>PRAGMATICENGINEER.COM</small>

Here’s a super-brief bullet summary of *“How Claude Code is built”*:

* Claude Code grew from a simple terminal prototype that could interact with the filesystem and evolved into a full internal tool. 
* The stack is TypeScript + React + Ink + Yoga + Bun, chosen because Claude models are already strong in those “on-distribution” technologies. 
* Around **90% of Claude Code’s own code** is generated by Claude itself. 
* The tool architecture is minimal: the model handles most logic (UI, file traversal, tool use), and the client layer stays lightweight. 
* It runs **locally**, not in a sandbox or VM; permissions are granted interactively by the user before changes. 
* The permissions system is multi-tiered (project / user / company), with whitelisting and command analysis. 
* Feature development is extremely fast: dozens of internal releases per day, ~1 external release per day, and heavy prototyping (e.g. ~20 variants in 2 days) 
* Terminal UX is reimagined: dynamic interactions, to-do list UI elements, toggleable displays, etc. 
* “AI-first engineering” practices: using agents for code reviews, test automation, feature flags, tightly integrating model feedback into dev workflows. 
* The article suggests Claude Code is a model for how future fast-moving, AI-augmented engineering teams might operate. 

## [The RAG Obituary: Killed by Agents, Buried by Context Windows](https://www.nicolasbustamante.com/p/the-rag-obituary-killed-by-agents)

<small>NICOLASBUSTAMANTE.COM</small>

* Bustamante argues that **RAG (Retrieval-Augmented Generation)** is becoming obsolete as context windows grow and agentic systems mature. 
* Traditional RAG pipelines suffer from cascading failure modes (chunking, embedding, reranking, hybrid search complexity) and high infrastructure costs. 
* Claude Code is presented as a countermodel: instead of retrieval + embedding, it uses file system tools (grep, glob) plus agents to navigate code directly, avoiding chunking/embedding/reranking entirely. 
* In the new “context-rich” era, agents that can reason across large documents and maintain end-to-end context will supersede retrieval systems; RAG becomes a fallback rather than the core. 

