---
layout: post
title: ! 'Issue #23'
author: ceberhardt
published: true
thumbnail: img/23.jpg
summary: This week's issue focuses on agentic loops, the feedback mechanisms that allow AI coding agents to iteratively improve their work. Multiple articles demonstrate how this approach enables autonomous problem-solving, from building spec-compliant parsers to fixing hundreds of installation failures.
---

## [How I wrote JustHTML using coding agents](https://friendlybit.com/python/writing-justhtml-with-coding-agents/)

<small>FRIENDLYBIT.COM</small>

This feels like one of the most stark illustrations of how coding agents will fundamentally change the way we approach software development in the future ...

This post tells the story of how Emil built a spec-compliant HTML5 parser in Python (with zero dependencies), using a variety of different methods - all heavily reliant on coding agents. It's a brief blog post, but describes a fascinating journey.

If you're not already aware, HTML parsing is incredibly complicated due to the need to support all kinds of 'broken' HTML that exists across the internet. 

Emil started building a parser using a 'one shot' approach, in other words, asking Copilot to build a simple HTML5 parser. Following that, he built a compliant parser through a combination of human-guided refactoring and a heavy reliance on an autonomous 'agentic loop', in other words, giving copilot the ability to asses its own progress via the comprehensive test suite that already exists for HTML5 parsers.

![loop]({{"img/23.jpg"| absolute_url}})

<i>Image courtesy of Ludde Lorentz, [Unsplash](https://unsplash.com/photos/photo-of-spiral-white-stairs-YfCVCPMNd38)</i>

What follows was a meandering journey through porting to Rust, creating a more performant Python parser by asking the agent to take inspiration from an already-optimised Rust library, fuzz testing, and much more.

This blog post is a real eye opener, exploring all sorts of techniques that were simply not possible before. And as Emil himself is keen to point out, he doesn't understand HTML5 terribly well himself, yet, he has built a compliant and performant parser.

How times have changed.

## [I ported JustHTML from Python to JavaScript with Codex CLI and GPT-5.2 in 4.5 hours](https://simonwillison.net/2025/Dec/15/porting-justhtml/)

<small>SIMONWILLISON.NET</small>

Very shortly after Emil published his post, Simon followed up with another impressive demonstration - porting Emil's (Python) parser using GPT 5.2 / Codex CLI. After just a few hours of work it produced a fully functional JavaScript implementation, with a test suite that passed. 

It's worth noting that the specific tool (model or agentic environment) used by Simon or Emil isn't that important, what allowed them both to be so successfull is the agentic loop that they constructed. A reasoning model, given a well-defined goal and a feedback mechanism that allows it to evaluate its progress towards that goal can do amazing things.

Another thing I find quite notable here is that the prompts used by both Emil and Simon were really quite simple. Once again, the feedback loop is far more important than some sophisticated prompting technique. Yes, I am a [specification driven development skeptic](https://blog.scottlogic.com/2025/11/26/putting-spec-kit-through-its-paces-radical-idea-or-reinvented-waterfall.html)!

## [Prediction: AI will make formal verification go mainstream](https://martin.kleppmann.com/2025/12/08/ai-formal-verification.html)

<small>KLEPPMANN.COM</small>

Formal verification is a concept that has been around since before programming and computers, through the work of GÃ¶del, Church, and Turing. Through formal proof you can prove that a software system correctly implements some form of specification, and as a result, verify that a specific class of bugs are not present in the implementation (without the need for testing or running the code). 

However, constructing formal proof is itself a challenging task and this is one of the reasons it has very limited adoption. In 25+ years of programming I've never worked on a system that had been formally proven.

In this post Martin argues that LLMs should make it easier to generate formal proofs and as a result, this practice will gain widespread adoption.

It is an interesting idea, but unfortunately formal proofs don't address the many other problems we face when building software systems, such as unclear requirements, unexpected user behaviours, poor user experiences. 

## [The highest quality codebase](https://gricha.dev/blog/the-highest-quality-codebase/)

<small>GRICHA.DEV</small>

Just for the fun of it, this post took a project, and iterated the following prompt, 200 times!

> "Ultrathink. You're a principal engineer. Do not ask me any questions. We need to improve the quality of this codebase.  Implement improvements to codebase quality."

What could possibly go wrong?

The changes Claude made were pretty funny, test cases increasing from 700 to 5369, a ten-fold increase in comments, re-implementation of various dependencies, functional utility methods - including a TypeScript re-implementation of Rust's `Result` type. 

While this is a funny post, it does make a more serious point - agents need clear goals and a way to verify their progress towards them. "Improve code quality" is not a clear goal, and in this instance there was no feedback loop.

## [How I (almost) replaced myself with AI](https://medium.com/@eric.hidari/how-i-almost-replaced-myself-with-ai-8478e6b85142)

<small>MEDIUM.COM</small>

While I typically use AI for content creation, whether that is code on prose, I have recently started using it (and more specifically Claude Code) for problem solving. This post takes that concept to the next level.

In this post Eric shares that part of his job involves maintaining the installation scripts for software that runs across a supercomputer cluster. When installations fail, the debugging process involves inspecting the log files, identifying the root cause, updating the installation script (recipe) then trying again. Often this involves quite a few iterations before a satisfactory fix is found.

Given that almost all the posts in this issue have been about agentic loops, I think you can see where this is going ...

Eric used the Codex CLI, and a relatively simple prompt, to create the required feedback loop for the agent to fix installation issues.

This wasn't just an academic exercise, a recent dependency update caused 109 installation failures. The agent fixed them all within 3 days - something that would have taken Eric weeks to resolve.


