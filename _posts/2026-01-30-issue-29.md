---
layout: post
title: ! 'Issue #29'
author: ceberhardt
published: true
thumbnail: img/29.png
summary: This issue explores the realities of agentic coding, highlighting both the speed and pitfalls of large-scale AI-driven code generation. It contrasts autonomous agent approaches with human-guided engineering, revealing the nuanced challenges and opportunities in AI-accelerated software development.
---

## [Porting 100k lines from TypeScript to Rust using Claude Code in a month](https://blog.vjeux.com/2026/analysis/porting-100k-lines-from-typescript-to-rust-using-claude-code-in-a-month.html)

<small>VJEUX.COM</small>

This is an amazing story of how Chris Chedeau (AKA Vjeux) ported a 100k line TypeScript library to Rust, in just 4 weeks, without writing a single line of code himself. Oh yes ... and he has never written Rust code either!

And the final Rust port is 3.5x faster than the JavaScript equivalent.

(as an aside, this is the same Chedeau / Vjeux who inspired me to [use an agentic loop to implement flexbox](https://blog.scottlogic.com/2025/12/22/power-of-agentic-loops.html) a few weeks back, repeating a task he did 10 years ago in implementing React Native)

The first part of his post describes the hacked together harness, escaping the sandbox (to allow pushing to GitHub), running binaries, and a Ralph-loop style 'keep going' using AppleScript.

His first attempt was simple, he just asked Claude to "port the codebase and make sure that things are done line by line". It created a lot of code, but took shortcuts, created duplication and poor abstractions. Claude can code, but it cannot architect.

His next attempt was to ask Claude to write a script that takes all the files and methods in the JavaScript codebase and migrate function by function. In other words, follow teh existing structure and architecture. Claude churned away on daily iterations, with Chris providing review and clean up tasks.

Next, the test suite. Claude generated the whole test harness and fixed all the issues without any human feedback, at a rate of one issue per 20 mins.

Three weeks later, 100k lines of code, 5k commits, and a fully functional Rust port.

## [One Human + One Agent = One Browser From Scratch](https://emsh.cat/one-human-one-agent-one-browser/)

<small>EMSH.CAT</small>

A couple of week ago the Cursor team published a blog post on [scaling long-running autonomous coding](https://cursor.com/blog/scaling-agents) where they demonstrated how a team of AI agents tackled a complex software development task by implementing a web browser, in a 3 week autonomous coding session. The fleet of agents ultimately created ~3 million lines of code, which does sound impressive. Unfortunately the code didn't compile, was messy and re-used existing libraries rather than implement many of the key algorithms required for a browser. Oh dear!

While the Cursor CEO used this to champion long-running autonomous coding, for many it had the adverse effect, demonstrating that AI tools are currently very good at writing code, but are not very good at the _engineering_ part of software engineering.

This blog post also uses AI to implement a browser, from scratch, but under the watchful eye of an experienced engineer. Rather than chase speed using multiple agents in parallel, a single agent is more than capable of emitting code faster than a human being can review and evaluate. Through thoughtful direction, and a close eye on the architecture, it is possible to build a basic, yet functional browser in a few days. This time with just 20k lines of code and zero dependencies.

## [The 80% Problem in Agentic Coding](https://addyo.substack.com/p/the-80-problem-in-agentic-coding)

<small>SUBSTACK.COM</small>

This post opens with a quote from Andrej Karpathy (who famously coined the term vibe coding):

> “I rapidly went from about 80% manual+autocomplete coding and 20% agents to 80% agent coding and 20% edits+touchups. I really am mostly programming in English now.”

This captures the shift that many prominent technologists experienced over the holiday period when they had time to experiment and reflect. This captures my experience too - I lean on AI agents to write pretty much all of my code.

However, this hasn't thrust us into a world of infinite productivity. AI accelerated software development still has its challenges, but the failure modes have changed.

This blog post explores the failure modes of AI-first software engineering ([vibe engineering](https://simonwillison.net/2025/Oct/7/vibe-engineering/) to use the term Simon Willison coined, but has failed to catch on). These include assumption propagation, abstraction bloat, sycophantic agreement and a number of others. Addy also covers more long-term impacts including comprehension debt and teh growing gap in AI adoption.

This is a really interesting post that takes a deep dive into this new world of software engineering that is rapidly evolving around us.

## [Unrolling the Codex agent loop](https://openai.com/index/unrolling-the-codex-agent-loop/)

<small>OPENAI.COM</small>

![agentic loop]({{"img/29.png"| absolute_url}})

And finally, this post from OpenAI takes a look under-the-hood, revealing how the 'agentic loop' works. This pattern is fundamentally how all AI coding agents work, and while you don't have to know the underlying technical detail, personally I think this knowledge helps you become more adapt at using them.